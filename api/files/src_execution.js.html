---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v0.1.35</span>
                        <h1 class="file-heading">File: src/execution.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import $ from &#x27;jquery&#x27;;
                        import md5 from &#x27;md5&#x27;;
                        
                        import {
                            ajax,
                            post
                        } from &#x27;./xhr&#x27;;
                        
                        import {
                            filter,
                            map,
                            every,
                            get,
                            isEmpty,
                            negate,
                            last,
                            assign,
                            find,
                            partial,
                            identity,
                            flatten,
                            values,
                            isString
                        } from &#x27;lodash&#x27;;
                        
                        const notEmpty = negate(isEmpty);
                        
                        /**
                         * Module for execution on experimental execution resource
                         *
                         * @class execution
                         * @module execution
                         */
                        
                        /**
                         * For the given projectId it returns table structure with the given
                         * elements in column headers.
                         *
                         * @method getData
                         * @param {String} projectId - GD project identifier
                         * @param {Array} elements - An array of attribute or metric identifiers.
                         * @param {Object} executionConfiguration - Execution configuration - can contain for example
                         *                 property &quot;filters&quot; containing execution context filters
                         *                 property &quot;where&quot; containing query-like filters
                         *                 property &quot;orderBy&quot; contains array of sorted properties to order in form
                         *                      [{column: &#x27;identifier&#x27;, direction: &#x27;asc|desc&#x27;}]
                         *
                         * @return {Object} Structure with &#x60;headers&#x60; and &#x60;rawData&#x60; keys filled with values from execution.
                         */
                        export function getData(projectId, elements, executionConfiguration = {}) {
                            const executedReport = {
                                isLoaded: false
                            };
                        
                            // Create request and result structures
                            const request = {
                                execution: {
                                    columns: elements
                                }
                            };
                            // enrich configuration with supported properties such as
                            // where clause with query-like filters or execution context filters
                            [&#x27;filters&#x27;, &#x27;where&#x27;, &#x27;orderBy&#x27;, &#x27;definitions&#x27;].forEach(property =&gt; {
                                if (executionConfiguration[property]) {
                                    request.execution[property] = executionConfiguration[property];
                                }
                            });
                        
                            /*eslint-disable new-cap*/
                            const d = $.Deferred();
                            /*eslint-enable new-cap*/
                        
                            // Execute request
                            post(&#x27;/gdc/internal/projects/&#x27; + projectId + &#x27;/experimental/executions&#x27;, {
                                data: JSON.stringify(request)
                            }, d.reject).then(function resolveSimpleExecution(result) {
                                // TODO: when executionResult.headers will be globaly available columns map code should be removed
                                if (result.executionResult.headers) {
                                    executedReport.headers = result.executionResult.headers;
                                } else {
                                    // Populate result&#x27;s header section if is not available
                                    executedReport.headers = result.executionResult.columns.map(function mapColsToHeaders(col) {
                                        if (col.attributeDisplayForm) {
                                            return {
                                                type: &#x27;attrLabel&#x27;,
                                                id: col.attributeDisplayForm.meta.identifier,
                                                uri: col.attributeDisplayForm.meta.uri,
                                                title: col.attributeDisplayForm.meta.title
                                            };
                                        }
                                        return {
                                            type: &#x27;metric&#x27;,
                                            id: col.metric.meta.identifier,
                                            uri: col.metric.meta.uri,
                                            title: col.metric.meta.title,
                                            format: col.metric.content.format
                                        };
                                    });
                                }
                                // Start polling on url returned in the executionResult for tabularData
                                return ajax(result.executionResult.tabularDataResult);
                            }, d.reject).then(function resolveDataResultPolling(result, message, response) {
                                // After the retrieving computed tabularData, resolve the promise
                                executedReport.rawData = (result &amp;&amp; result.tabularDataResult) ? result.tabularDataResult.values : [];
                                executedReport.isLoaded = true;
                                executedReport.isEmpty = (response.status === 204);
                                d.resolve(executedReport);
                            }, d.reject);
                        
                            return d.promise();
                        }
                        
                        const CONTRIBUTION_METRIC_FORMAT = &#x27;#,##0.00%&#x27;;
                        
                        const hashItem = item =&gt; md5(&#x60;${filter(values(item), isString).join(&#x27;#&#x27;)}&#x60;);
                        
                        const getFilterExpression = listAttributeFilter =&gt; {
                            const attributeUri = get(listAttributeFilter, &#x27;listAttributeFilter.attribute&#x27;);
                            const elements = get(listAttributeFilter, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            if (isEmpty(elements)) {
                                return null;
                            }
                            const elementsForQuery = map(elements, e =&gt; &#x60;[${e}]&#x60;);
                            const negative = get(listAttributeFilter, &#x27;listAttributeFilter.default.negativeSelection&#x27;) ? &#x27;NOT &#x27; : &#x27;&#x27;;
                        
                            return &#x60;[${attributeUri}] ${negative}IN (${elementsForQuery.join(&#x27;,&#x27;)})&#x60;;
                        };
                        
                        const getGeneratedMetricExpression = item =&gt; {
                            const aggregation = get(item, &#x27;aggregation&#x27;, &#x27;&#x27;).toUpperCase();
                            const objectUri = get(item, &#x27;objectUri&#x27;);
                            const where = filter(map(get(item, &#x27;measureFilters&#x27;), getFilterExpression), e =&gt; !!e);
                        
                            return &#x27;SELECT &#x27; + (aggregation ? &#x60;${aggregation}([${objectUri}])&#x60; : &#x60;[${objectUri}]&#x60;) +
                                (notEmpty(where) ? &#x60; WHERE ${where.join(&#x27; AND &#x27;)}&#x60; : &#x27;&#x27;);
                        };
                        
                        const getPercentMetricExpression = (attribute, metricId) =&gt; {
                            const attributeUri = get(attribute, &#x27;attribute&#x27;);
                        
                            return &#x60;SELECT (SELECT ${metricId}) / (SELECT ${metricId} BY ALL [${attributeUri}])&#x60;;
                        };
                        
                        const getPoPExpression = (attribute, metricId) =&gt; {
                            const attributeUri = get(attribute, &#x27;attribute&#x27;);
                        
                            return &#x60;SELECT (SELECT ${metricId}) FOR PREVIOUS ([${attributeUri}])&#x60;;
                        };
                        
                        const getGeneratedMetricHash = (title, format, expression) =&gt; md5(&#x60;${expression}#${title}#${format}&#x60;);
                        
                        const allFiltersEmpty = item =&gt; every(map(
                            get(item, &#x27;measureFilters&#x27;, []),
                            f =&gt; isEmpty(get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []))
                        ));
                        
                        const getGeneratedMetricIdentifier = (item, aggregation, expressionCreator, hasher) =&gt; {
                            const [, , , prjId, , id] = get(item, &#x27;objectUri&#x27;).split(&#x27;/&#x27;);
                            const identifier = &#x60;${prjId}_${id}&#x60;;
                            const hash = hasher(expressionCreator(item));
                            const hasNoFilters = isEmpty(get(item, &#x27;measureFilters&#x27;, []));
                            const type = get(item, &#x27;type&#x27;);
                        
                            const prefix = (hasNoFilters || allFiltersEmpty(item)) ? &#x27;&#x27; : &#x27;filtered_&#x27;;
                        
                            return &#x60;${type}_${identifier}.generated.${prefix}${aggregation}.${hash}&#x60;;
                        };
                        
                        const generatedMetricDefinition = item =&gt; {
                            const { title, format, sort } = item;
                        
                            const hasher = partial(getGeneratedMetricHash, title, format);
                            const aggregation = get(item, &#x27;aggregation&#x27;, &#x27;base&#x27;).toLowerCase();
                            const element = getGeneratedMetricIdentifier(item, aggregation, getGeneratedMetricExpression, hasher);
                            const definition = {
                                metricDefinition: {
                                    identifier: element,
                                    expression: getGeneratedMetricExpression(item),
                                    title,
                                    format
                                }
                            };
                        
                            return { element, hash: hashItem(item), definition, sort };
                        };
                        
                        const isDerivedMetric = (item) =&gt; {
                            const type = get(item, &#x27;type&#x27;);
                            return (type === &#x27;fact&#x27; || type === &#x27;attribute&#x27; || !allFiltersEmpty(item));
                        };
                        
                        const contributionMetricDefinition = (attribute, item) =&gt; {
                            let generated;
                            let getMetricExpression = partial(getPercentMetricExpression, attribute, &#x60;[${get(item, &#x27;objectUri&#x27;)}]&#x60;);
                            if (isDerivedMetric(item)) {
                                generated = generatedMetricDefinition(item);
                                getMetricExpression = partial(getPercentMetricExpression, attribute, &#x60;{${get(generated, &#x27;definition.metricDefinition.identifier&#x27;)}}&#x60;);
                            }
                            const title = &#x60;% ${get(item, &#x27;title&#x27;)}&#x60;.replace(/^(% )+/, &#x27;% &#x27;);
                            const hasher = partial(getGeneratedMetricHash, title, CONTRIBUTION_METRIC_FORMAT);
                            const result = [{
                                element: getGeneratedMetricIdentifier(item, &#x27;percent&#x27;, getMetricExpression, hasher),
                                hash: hashItem(item),
                                definition: {
                                    metricDefinition: {
                                        identifier: getGeneratedMetricIdentifier(item, &#x27;percent&#x27;, getMetricExpression, hasher),
                                        expression: getMetricExpression(item),
                                        title,
                                        format: CONTRIBUTION_METRIC_FORMAT
                                    }
                                },
                                sort: get(item, &#x27;sort&#x27;)
                            }];
                        
                            if (generated) {
                                result.unshift({ hash: hashItem(item), definition: generated.definition });
                            }
                        
                            return result;
                        };
                        
                        const getDate = date =&gt; get(date, &#x27;dateFilter&#x27;, date);
                        
                        const popMetricDefinition = (attribute, item) =&gt; {
                            const title = &#x60;${get(item, &#x27;title&#x27;)} - previous year&#x60;;
                            const format = get(item, &#x27;format&#x27;);
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const date = getDate(attribute);
                        
                            let generated;
                            let getMetricExpression = partial(getPoPExpression, date, &#x60;[${get(item, &#x27;objectUri&#x27;)}]&#x60;);
                        
                            if (isDerivedMetric(item)) {
                                generated = generatedMetricDefinition(item);
                                getMetricExpression = partial(getPoPExpression, date, &#x60;{${get(generated, &#x27;definition.metricDefinition.identifier&#x27;)}}&#x60;);
                            }
                        
                            const identifier = getGeneratedMetricIdentifier(item, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                hash: hashItem(item),
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                },
                                sort: get(item, &#x27;sort&#x27;)
                            }];
                        
                            if (generated) {
                                result.push(generated);
                            }
                        
                            return result;
                        };
                        
                        const contributionPoPMetricDefinition = (date, attribute, item) =&gt; {
                            const generated = contributionMetricDefinition(attribute ? attribute : date, item);
                        
                            const title = &#x60;% ${get(item, &#x27;title&#x27;)} - previous year&#x60;.replace(/^(% )+/, &#x27;% &#x27;);
                            const format = CONTRIBUTION_METRIC_FORMAT;
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const getMetricExpression = partial(getPoPExpression, getDate(date), &#x60;{${last(generated).element}}&#x60;);
                        
                            const identifier = getGeneratedMetricIdentifier(item, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                hash: hashItem(item),
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                },
                                sort: get(item, &#x27;sort&#x27;)
                            }];
                        
                            result.push(generated);
                        
                            return flatten(result);
                        };
                        
                        const categoryToElement = c =&gt; ({ element: get(c, &#x27;displayForm&#x27;), hash: hashItem(c), sort: get(c, &#x27;sort&#x27;) });
                        
                        const attributeFilterToWhere = f =&gt; {
                            const dfUri = get(f, &#x27;listAttributeFilter.displayForm&#x27;);
                            const elements = get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            const elementsForQuery = map(elements, e =&gt; ({
                                id: last(e.split(&#x27;=&#x27;))
                            }));
                            const negative = get(f, &#x27;listAttributeFilter.default.negativeSelection&#x27;) ? &#x27;NOT &#x27; : &#x27;&#x27;;
                        
                            return negative ?
                                { [dfUri]: { &#x27;$not&#x27;: { &#x27;$in&#x27;: elementsForQuery } } } :
                                { [dfUri]: { &#x27;$in&#x27;: elementsForQuery } };
                        };
                        
                        const dateFilterToWhere = f =&gt; {
                            const dimensionUri = get(f, &#x27;dateFilter.dimension&#x27;);
                            const granularity = get(f, &#x27;dateFilter.granularity&#x27;);
                            const between = [get(f, &#x27;dateFilter.from&#x27;), get(f, &#x27;dateFilter.to&#x27;)];
                            return { [dimensionUri]: { &#x27;$between&#x27;: between, &#x27;$granularity&#x27;: granularity } };
                        };
                        
                        const metricToDefinition = metric =&gt; ({
                            element: get(metric, &#x27;objectUri&#x27;),
                            hash: hashItem(metric),
                            sort: !metric.showPoP ? get(metric, &#x27;sort&#x27;) : null
                        });
                        
                        const isDateFilterExecutable = dateFilter =&gt;
                            get(dateFilter, &#x27;from&#x27;) !== undefined &amp;&amp;
                            get(dateFilter, &#x27;to&#x27;) !== undefined;
                        
                        const isAttributeFilterExecutable = listAttributeFilter =&gt;
                            notEmpty(get(listAttributeFilter, [&#x27;default&#x27;, &#x27;attributeElements&#x27;]));
                        
                        const sortToOrderBy = item =&gt; ({ column: get(item, &#x27;element&#x27;), direction: get(item, &#x27;sort&#x27;) });
                        
                        export const mdToExecutionConfiguration = (mdObj) =&gt; {
                            const { filters } = mdObj;
                            const measures = map(mdObj.measures, ({ measure }) =&gt; measure);
                            const measureSort = map(measures, hashItem);
                            const categories = map(mdObj.categories, ({ category }) =&gt; category);
                            const attributes = map(categories, categoryToElement);
                            const contributionMetrics = map(
                                filter(measures, m =&gt; m.showInPercent &amp;&amp; !m.showPoP),
                                partial(contributionMetricDefinition, find(categories, c =&gt; c.type === &#x27;attribute&#x27; || c.type === &#x27;date&#x27;))
                            );
                        
                            const date = find([].concat(categories, filters), c =&gt; (c.type === &#x27;date&#x27; || c.dateFilter));
                        
                            const popMetrics = map(
                                filter(measures, m =&gt; m.showPoP &amp;&amp; !m.showInPercent),
                                partial(popMetricDefinition, date)
                            );
                            const contributionPoPMetrics = map(
                                filter(measures, m =&gt; m.showPoP &amp;&amp; m.showInPercent),
                                partial(contributionPoPMetricDefinition, date, find(categories, c =&gt; c.type === &#x27;attribute&#x27; || c.type === &#x27;date&#x27;))
                            );
                            const factMetrics = map(filter(measures, m =&gt; m.type === &#x27;fact&#x27; &amp;&amp; !m.showInPercent &amp;&amp; !m.showPoP), generatedMetricDefinition);
                            const metrics = map(filter(measures, m =&gt; m.type === &#x27;metric&#x27; &amp;&amp; !m.showInPercent), metric =&gt; {
                                if (isEmpty(metric.measureFilters)) {
                                    return metricToDefinition(metric);
                                }
                        
                                return generatedMetricDefinition(metric);
                            });
                            const attributeMetrics = map(filter(measures, m =&gt; m.type === &#x27;attribute&#x27; &amp;&amp; !m.showInPercent &amp;&amp; !m.showPoP), generatedMetricDefinition);
                            const attributeFilters = map(filter(filters, ({ listAttributeFilter }) =&gt; isAttributeFilterExecutable(listAttributeFilter)), attributeFilterToWhere);
                            const dateFilters = map(filter(filters, ({ dateFilter }) =&gt; isDateFilterExecutable(dateFilter)), dateFilterToWhere);
                        
                            const allMetrics = [].concat(
                                factMetrics,
                                attributeMetrics,
                                popMetrics,
                                metrics,
                                contributionMetrics,
                                contributionPoPMetrics
                            );
                        
                            const allMetricsSorted = map(measureSort, (hash) =&gt; {
                                return filter(flatten(allMetrics), metric =&gt; {
                                    return metric.hash === hash;
                                });
                            });
                        
                            const allItems = [].concat(
                                attributes,
                                flatten(allMetricsSorted)
                            );
                        
                            const orderBy = map(filter(allItems, item =&gt; !!item.sort), sortToOrderBy);
                            const where = [].concat(attributeFilters, dateFilters).reduce(assign, {});
                        
                            return { execution: {
                                columns: filter(map(allItems, &#x27;element&#x27;), identity),
                                orderBy,
                                where,
                                definitions: filter(map(allItems, &#x27;definition&#x27;), identity)
                            } };
                        };
                        
                        export const getDataForVis = (projectId, mdObj) =&gt; {
                            const { execution } = mdToExecutionConfiguration(get(mdObj, &#x27;buckets&#x27;));
                            const { columns, ...executionConfiguration } = execution;
                            return getData(projectId, columns, executionConfiguration);
                        };
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

