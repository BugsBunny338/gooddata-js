---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v0.1.46</span>
                        <h1 class="file-heading">File: src/execution.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import $ from &#x27;jquery&#x27;;
                        import md5 from &#x27;md5&#x27;;
                        
                        import {
                            ajax,
                            post
                        } from &#x27;./xhr&#x27;;
                        
                        import Rules from &#x27;./utils/rules&#x27;;
                        import { sortDefinitions } from &#x27;./utils/definitions&#x27;;
                        
                        import invariant from &#x27;invariant&#x27;;
                        import {
                            compact,
                            filter,
                            first,
                            find,
                            map,
                            every,
                            get,
                            isEmpty,
                            negate,
                            last,
                            assign,
                            partial,
                            flatten,
                        } from &#x27;lodash&#x27;;
                        
                        const notEmpty = negate(isEmpty);
                        
                        /**
                         * Module for execution on experimental execution resource
                         *
                         * @class execution
                         * @module execution
                         */
                        
                        /**
                         * For the given projectId it returns table structure with the given
                         * elements in column headers.
                         *
                         * @method getData
                         * @param {String} projectId - GD project identifier
                         * @param {Array} elements - An array of attribute or metric identifiers.
                         * @param {Object} executionConfiguration - Execution configuration - can contain for example
                         *                 property &quot;filters&quot; containing execution context filters
                         *                 property &quot;where&quot; containing query-like filters
                         *                 property &quot;orderBy&quot; contains array of sorted properties to order in form
                         *                      [{column: &#x27;identifier&#x27;, direction: &#x27;asc|desc&#x27;}]
                         *
                         * @return {Object} Structure with &#x60;headers&#x60; and &#x60;rawData&#x60; keys filled with values from execution.
                         */
                        export function getData(projectId, elements, executionConfiguration = {}) {
                            const executedReport = {
                                isLoaded: false
                            };
                        
                            // Create request and result structures
                            const request = {
                                execution: {
                                    columns: elements
                                }
                            };
                            // enrich configuration with supported properties such as
                            // where clause with query-like filters or execution context filters
                            [&#x27;filters&#x27;, &#x27;where&#x27;, &#x27;orderBy&#x27;, &#x27;definitions&#x27;].forEach(property =&gt; {
                                if (executionConfiguration[property]) {
                                    request.execution[property] = executionConfiguration[property];
                                }
                            });
                        
                            /*eslint-disable new-cap*/
                            const d = $.Deferred();
                            /*eslint-enable new-cap*/
                        
                            // Execute request
                            post(&#x27;/gdc/internal/projects/&#x27; + projectId + &#x27;/experimental/executions&#x27;, {
                                data: JSON.stringify(request)
                            }, d.reject).then(function resolveSimpleExecution(result) {
                                // TODO: when executionResult.headers will be globaly available columns map code should be removed
                                if (result.executionResult.headers) {
                                    executedReport.headers = result.executionResult.headers;
                                } else {
                                    // Populate result&#x27;s header section if is not available
                                    executedReport.headers = result.executionResult.columns.map(function mapColsToHeaders(col) {
                                        if (col.attributeDisplayForm) {
                                            return {
                                                type: &#x27;attrLabel&#x27;,
                                                id: col.attributeDisplayForm.meta.identifier,
                                                uri: col.attributeDisplayForm.meta.uri,
                                                title: col.attributeDisplayForm.meta.title
                                            };
                                        }
                                        return {
                                            type: &#x27;metric&#x27;,
                                            id: col.metric.meta.identifier,
                                            uri: col.metric.meta.uri,
                                            title: col.metric.meta.title,
                                            format: col.metric.content.format
                                        };
                                    });
                                }
                                // Start polling on url returned in the executionResult for tabularData
                                return ajax(result.executionResult.tabularDataResult);
                            }, d.reject).then(function resolveDataResultPolling(result, message, response) {
                                // After the retrieving computed tabularData, resolve the promise
                                executedReport.rawData = (result &amp;&amp; result.tabularDataResult) ? result.tabularDataResult.values : [];
                                executedReport.isLoaded = true;
                                executedReport.isEmpty = (response.status === 204);
                                d.resolve(executedReport);
                            }, d.reject);
                        
                            return d.promise();
                        }
                        
                        const MAX_TITLE_LENGTH = 255;
                        const getMetricTitle = (suffix, title) =&gt; {
                            const maxLength = MAX_TITLE_LENGTH - suffix.length;
                            if (title &amp;&amp; title.length &gt; maxLength) {
                                if (title[title.length - 1] === &#x27;)&#x27;) {
                                    return &#x60;${title.substring(0, maxLength - 2)}…)${suffix}&#x60;;
                                }
                                return &#x60;${title.substring(0, maxLength - 1)}…${suffix}&#x60;;
                            }
                            return &#x60;${title}${suffix}&#x60;;
                        };
                        
                        const getBaseMetricTitle = partial(getMetricTitle, &#x27;&#x27;);
                        
                        const POP_SUFFIX = &#x27; - previous year&#x27;;
                        const getPoPMetricTitle = partial(getMetricTitle, POP_SUFFIX);
                        
                        const CONTRIBUTION_METRIC_FORMAT = &#x27;#,##0.00%&#x27;;
                        
                        const getFilterExpression = listAttributeFilter =&gt; {
                            const attributeUri = get(listAttributeFilter, &#x27;listAttributeFilter.attribute&#x27;);
                            const elements = get(listAttributeFilter, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            if (isEmpty(elements)) {
                                return null;
                            }
                            const elementsForQuery = map(elements, e =&gt; &#x60;[${e}]&#x60;);
                            const negative = get(listAttributeFilter, &#x27;listAttributeFilter.default.negativeSelection&#x27;) ? &#x27;NOT &#x27; : &#x27;&#x27;;
                        
                            return &#x60;[${attributeUri}] ${negative}IN (${elementsForQuery.join(&#x27;,&#x27;)})&#x60;;
                        };
                        
                        const getGeneratedMetricExpression = item =&gt; {
                            const aggregation = get(item, &#x27;aggregation&#x27;, &#x27;&#x27;).toUpperCase();
                            const objectUri = get(item, &#x27;objectUri&#x27;);
                            const where = filter(map(get(item, &#x27;measureFilters&#x27;), getFilterExpression), e =&gt; !!e);
                        
                            return &#x27;SELECT &#x27; + (aggregation ? &#x60;${aggregation}([${objectUri}])&#x60; : &#x60;[${objectUri}]&#x60;) +
                                (notEmpty(where) ? &#x60; WHERE ${where.join(&#x27; AND &#x27;)}&#x60; : &#x27;&#x27;);
                        };
                        
                        const getPercentMetricExpression = ({ category }, metricId) =&gt; {
                            const attributeUri = get(category, &#x27;attribute&#x27;);
                        
                            return &#x60;SELECT (SELECT ${metricId}) / (SELECT ${metricId} BY ALL [${attributeUri}])&#x60;;
                        };
                        
                        const getPoPExpression = (attribute, metricId) =&gt; {
                            const attributeUri = get(attribute, &#x27;attribute&#x27;);
                        
                            return &#x60;SELECT (SELECT ${metricId}) FOR PREVIOUS ([${attributeUri}])&#x60;;
                        };
                        
                        const getGeneratedMetricHash = (title, format, expression) =&gt; md5(&#x60;${expression}#${title}#${format}&#x60;);
                        
                        const allFiltersEmpty = item =&gt; every(map(
                            get(item, &#x27;measureFilters&#x27;, []),
                            f =&gt; isEmpty(get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []))
                        ));
                        
                        const getGeneratedMetricIdentifier = (item, aggregation, expressionCreator, hasher) =&gt; {
                            const [, , , prjId, , id] = get(item, &#x27;objectUri&#x27;).split(&#x27;/&#x27;);
                            const identifier = &#x60;${prjId}_${id}&#x60;;
                            const hash = hasher(expressionCreator(item));
                            const hasNoFilters = isEmpty(get(item, &#x27;measureFilters&#x27;, []));
                            const type = get(item, &#x27;type&#x27;);
                        
                            const prefix = (hasNoFilters || allFiltersEmpty(item)) ? &#x27;&#x27; : &#x27;filtered_&#x27;;
                        
                            return &#x60;${type}_${identifier}.generated.${prefix}${aggregation}.${hash}&#x60;;
                        };
                        
                        const isDerived = measure =&gt; {
                            const type = get(measure, &#x27;type&#x27;);
                            return (type === &#x27;fact&#x27; || type === &#x27;attribute&#x27; || !allFiltersEmpty(measure));
                        };
                        
                        const isDateCategory = ({ category }) =&gt; category.type === &#x27;date&#x27;;
                        const isDateFilter = ({ dateFilter }) =&gt; dateFilter;
                        
                        const getCategories = ({ categories }) =&gt; categories;
                        const getFilters = ({ filters }) =&gt; filters;
                        
                        const getDateCategory = mdObj =&gt; {
                            const category = find(getCategories(mdObj), isDateCategory);
                        
                            return get(category, &#x27;category&#x27;);
                        };
                        
                        const getDateFilter = mdObj =&gt; {
                            const dateFilter = find(getFilters(mdObj), isDateFilter);
                        
                            return get(dateFilter, &#x27;dateFilter&#x27;);
                        };
                        
                        const getDate = mdObj =&gt; (getDateCategory(mdObj) || getDateFilter(mdObj));
                        
                        const createPureMetric = measure =&gt; ({
                            element: get(measure, &#x27;objectUri&#x27;),
                            sort: get(measure, &#x27;sort&#x27;)
                        });
                        
                        const createDerivedMetric = measure =&gt; {
                            const { format, sort } = measure;
                            const title = getBaseMetricTitle(measure.title);
                        
                            const hasher = partial(getGeneratedMetricHash, title, format);
                            const aggregation = get(measure, &#x27;aggregation&#x27;, &#x27;base&#x27;).toLowerCase();
                            const element = getGeneratedMetricIdentifier(measure, aggregation, getGeneratedMetricExpression, hasher);
                            const definition = {
                                metricDefinition: {
                                    identifier: element,
                                    expression: getGeneratedMetricExpression(measure),
                                    title,
                                    format
                                }
                            };
                        
                            return { element, definition, sort };
                        };
                        
                        const createContributionMetric = (measure, mdObj) =&gt; {
                            const category = first(getCategories(mdObj));
                        
                            let generated;
                            let getMetricExpression = partial(getPercentMetricExpression, category, &#x60;[${get(measure, &#x27;objectUri&#x27;)}]&#x60;);
                            if (isDerived(measure)) {
                                generated = createDerivedMetric(measure);
                                getMetricExpression = partial(getPercentMetricExpression, category, &#x60;{${get(generated, &#x27;definition.metricDefinition.identifier&#x27;)}}&#x60;);
                            }
                            const title = getBaseMetricTitle(&#x60;% ${get(measure, &#x27;title&#x27;)}&#x60;.replace(/^(% )+/, &#x27;% &#x27;));
                            const hasher = partial(getGeneratedMetricHash, title, CONTRIBUTION_METRIC_FORMAT);
                            const result = [{
                                element: getGeneratedMetricIdentifier(measure, &#x27;percent&#x27;, getMetricExpression, hasher),
                                definition: {
                                    metricDefinition: {
                                        identifier: getGeneratedMetricIdentifier(measure, &#x27;percent&#x27;, getMetricExpression, hasher),
                                        expression: getMetricExpression(measure),
                                        title,
                                        format: CONTRIBUTION_METRIC_FORMAT
                                    }
                                },
                                sort: get(measure, &#x27;sort&#x27;)
                            }];
                        
                            if (generated) {
                                result.unshift({ definition: generated.definition });
                            }
                        
                            return result;
                        };
                        
                        const createPoPMetric = (measure, mdObj) =&gt; {
                            const title = getPoPMetricTitle(get(measure, &#x27;title&#x27;));
                            const format = get(measure, &#x27;format&#x27;);
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const date = getDate(mdObj);
                        
                            let generated;
                            let getMetricExpression = partial(getPoPExpression, date, &#x60;[${get(measure, &#x27;objectUri&#x27;)}]&#x60;);
                        
                            if (isDerived(measure)) {
                                generated = createDerivedMetric(measure);
                                getMetricExpression = partial(getPoPExpression, date, &#x60;{${get(generated, &#x27;definition.metricDefinition.identifier&#x27;)}}&#x60;);
                            }
                        
                            const identifier = getGeneratedMetricIdentifier(measure, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                }
                            }];
                        
                            if (generated) {
                                result.push(generated);
                            } else {
                                result.push(createPureMetric(measure));
                            }
                        
                            return result;
                        };
                        
                        const createContributionPoPMetric = (measure, mdObj) =&gt; {
                            const date = getDate(mdObj);
                        
                            const generated = createContributionMetric(measure, mdObj);
                            const title = getPoPMetricTitle(&#x60;% ${get(measure, &#x27;title&#x27;)}&#x60;.replace(/^(% )+/, &#x27;% &#x27;));
                        
                            const format = CONTRIBUTION_METRIC_FORMAT;
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const getMetricExpression = partial(getPoPExpression, date, &#x60;{${last(generated).element}}&#x60;);
                        
                            const identifier = getGeneratedMetricIdentifier(measure, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                }
                            }];
                        
                            result.push(generated);
                        
                            return flatten(result);
                        };
                        
                        const categoryToElement = ({ category }) =&gt;
                            ({ element: get(category, &#x27;displayForm&#x27;), sort: get(category, &#x27;sort&#x27;) });
                        
                        const attributeFilterToWhere = f =&gt; {
                            const elements = get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            const elementsForQuery = map(elements, e =&gt; ({ id: last(e.split(&#x27;=&#x27;)) }));
                        
                            const dfUri = get(f, &#x27;listAttributeFilter.displayForm&#x27;);
                            const negative = get(f, &#x27;listAttributeFilter.default.negativeSelection&#x27;);
                        
                            return negative ?
                                { [dfUri]: { &#x27;$not&#x27;: { &#x27;$in&#x27;: elementsForQuery } } } :
                                { [dfUri]: { &#x27;$in&#x27;: elementsForQuery } };
                        };
                        
                        const dateFilterToWhere = f =&gt; {
                            const dateUri = get(f, &#x27;dateFilter.dimension&#x27;) || get(f, &#x27;dateFilter.dataset&#x27;);
                            const granularity = get(f, &#x27;dateFilter.granularity&#x27;);
                            const between = [get(f, &#x27;dateFilter.from&#x27;), get(f, &#x27;dateFilter.to&#x27;)];
                            return { [dateUri]: { &#x27;$between&#x27;: between, &#x27;$granularity&#x27;: granularity } };
                        };
                        
                        const isPoP = ({ showPoP }) =&gt; showPoP;
                        const isContribution = ({ showInPercent }) =&gt; showInPercent;
                        
                        const isCalculatedMeasure = ({ type }) =&gt; type === &#x27;metric&#x27;;
                        
                        const rules = new Rules();
                        
                        rules.addRule(
                            [isPoP, isContribution],
                            createContributionPoPMetric
                        );
                        
                        rules.addRule(
                            [isPoP],
                            createPoPMetric
                        );
                        
                        rules.addRule(
                            [isContribution],
                            createContributionMetric
                        );
                        
                        rules.addRule(
                            [isDerived],
                            createDerivedMetric
                        );
                        
                        rules.addRule(
                            [isCalculatedMeasure],
                            createPureMetric
                        );
                        
                        function getMetricFactory(measure) {
                            const factory = rules.match(measure);
                        
                            invariant(factory, &#x60;Unknown factory for: ${measure}&#x60;);
                        
                            return factory;
                        }
                        
                        const isDateFilterExecutable = dateFilter =&gt;
                            get(dateFilter, &#x27;from&#x27;) !== undefined &amp;&amp;
                            get(dateFilter, &#x27;to&#x27;) !== undefined;
                        
                        const isAttributeFilterExecutable = listAttributeFilter =&gt;
                            notEmpty(get(listAttributeFilter, [&#x27;default&#x27;, &#x27;attributeElements&#x27;]));
                        
                        
                        function getWhere({ filters }) {
                            const attributeFilters = map(filter(filters, ({ listAttributeFilter }) =&gt; isAttributeFilterExecutable(listAttributeFilter)), attributeFilterToWhere);
                            const dateFilters = map(filter(filters, ({ dateFilter }) =&gt; isDateFilterExecutable(dateFilter)), dateFilterToWhere);
                        
                            return [...attributeFilters, ...dateFilters].reduce(assign, {});
                        }
                        
                        const sortToOrderBy = item =&gt; ({ column: get(item, &#x27;element&#x27;), direction: get(item, &#x27;sort&#x27;) });
                        
                        const getOrderBy = (metrics, categories, type) =&gt; {
                            // For bar chart we always override sorting to sort by values (first metric)
                            if (type === &#x27;bar&#x27; &amp;&amp; notEmpty(metrics)) {
                                return [{
                                    column: first(compact(map(metrics, &#x27;element&#x27;))),
                                    direction: &#x27;desc&#x27;
                                }];
                            }
                        
                            return map(filter([...categories, ...metrics], item =&gt; item.sort), sortToOrderBy);
                        };
                        
                        export const mdToExecutionConfiguration = (mdObj) =&gt; {
                            const buckets = get(mdObj, &#x27;buckets&#x27;);
                            const measures = map(buckets.measures, ({ measure }) =&gt; measure);
                            const metrics = flatten(map(measures, measure =&gt; getMetricFactory(measure)(measure, buckets)));
                            const categories = map(getCategories(buckets), categoryToElement);
                            const columns = compact(map([...categories, ...metrics], &#x27;element&#x27;));
                        
                            return { execution: {
                                columns,
                                orderBy: getOrderBy(metrics, categories, get(mdObj, &#x27;type&#x27;)),
                                definitions: sortDefinitions(compact(map(metrics, &#x27;definition&#x27;))),
                                where: columns.length ? getWhere(buckets) : {}
                            } };
                        };
                        
                        export const getDataForVis = (projectId, mdObj) =&gt; {
                            const { execution } = mdToExecutionConfiguration(mdObj);
                            const { columns, ...executionConfiguration } = execution;
                            return getData(projectId, columns, executionConfiguration);
                        };
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

